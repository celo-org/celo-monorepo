/* eslint-disable max-classes-per-file: 0 */
/*
 * The Solidity compiler appends a Swarm Hash of compilation metadata to the end
 * of bytecode. We find this hash based on the specification here:
 * https://solidity.readthedocs.io/en/develop/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode
 */

import { NULL_ADDRESS, trimLeading0x } from '@celo/base/lib/address'
import { Artifact, LinkReferences } from '@celo/protocol/lib/compatibility/internal'
import { keccak256, toHex } from 'viem'

const CONTRACT_METADATA_REGEXPS = [
  // 0.5.8
  'a165627a7a72305820.{64}0029',
  // 0.5.13
  'a265627a7a72315820.{64}64736f6c6343.{6}0032',
  // 0.8.19
  'a264697066735822.{68}64736f6c6343.{6}0033'
]

const GENERAL_METADATA_REGEXP = new RegExp(
  `^(.*)(${CONTRACT_METADATA_REGEXPS.map((r) => '(' + r + ')').join('|')})$`,
  'i' // Use i flag to make search case insensitive.
)

export const stripMetadata = (bytecode: string): string => {
  if (bytecode === '0x') {
    return '0x'
  }

  const match = bytecode.match(GENERAL_METADATA_REGEXP)
  if (match === null) {
    throw new Error(
      'Only support stripping metadata from bytecodes generated by solc in the versions listed in CONTRACT_METADATA_REGEXPS'
    )
  }
  return match[1]
}

// Maps library fully qualified library names to their onchain addresses (formatted without "0x" prefix).
export interface LibraryLinks {
  [name: string]: {
    address: string,
    placeholderHash: string
  }
}

/*
 * Unresolved libraries appear as "__$<hash>$__..." in bytecode output by
 * solc. The length of the entire string is 40 characters (accounting for the 20
 * bytes of the address that should be substituted in).
 */
const getPlaceholderHash = (name: string): string => {
  const hash = keccak256(toHex(name))
  return hash.slice(2, 2 + 34)
}


export const linkLibraries = (bytecode: string, libraryLinks: LibraryLinks): string => {
  Object.keys(libraryLinks).forEach((libraryName) => {
    const linkString = `__\\$${libraryLinks[libraryName].placeholderHash}\\$__`
    // Use g flag to iterate through for all occurences.
    bytecode = bytecode.replace(RegExp(linkString, 'g'), libraryLinks[libraryName].address)
  })

  return bytecode
}

const ADDRESS_LENGTH = 40
const PUSH20_OPCODE = '73'
// To check that a library isn't being called directly, the Solidity
// compiler starts a library's bytecode with a comparison of the current
// address with the address the library was deployed to (it has to differ
// to ensure the library is being called with CALLCODE or DELEGATECALL
// instead of a regular CALL).
// The address is only known at contract construction time, so
// the compiler's output contains a placeholder 0-address, while the onchain
// bytecode has the correct address inserted.
// Reference: https://solidity.readthedocs.io/en/v0.5.12/contracts.html#call-protection-for-libraries
export const verifyAndStripLibraryPrefix = (bytecode: string, address = NULL_ADDRESS) => {
  if (bytecode.slice(2, 4) !== PUSH20_OPCODE) {
    throw new Error(`Library bytecode doesn't start with address load`)
  } else if (bytecode.slice(4, 4 + ADDRESS_LENGTH) !== trimLeading0x(address).toLowerCase()) {
    throw new Error(`Library bytecode loads unexpected address at start`)
  }

  return bytecode.slice(4 + ADDRESS_LENGTH, bytecode.length)
}

/*
 * Stores info about libraries linked in an artifact.
 * Specifically, for each library, it stores:
 * - `positions`: an array of indices into the `deployedBytecode` string indicating the locations
 *    where the library should be linked.
 * - `placeholderHash`: the hexadecimal 34-character hash used as a placeholder before linking.
 */
export class ArtifactLibraryLinking {
  links: {
    [library: string]: {
      positions: number[]
      placeholderHash: string
    }
  }

  constructor(artifact: Artifact) {
    this.links = {}
    if (typeof artifact.deployedBytecode !== 'string') {
      this.parseLibraryPositions(artifact.deployedBytecode.linkReferences)
    } else {
      throw new Error(`Unexpected artifact type`)
    }
  }

  private parseLibraryPositions(references: LinkReferences) {
    Object.keys(references).forEach(sourceFile => {
      const libraryLinks = references[sourceFile]
      Object.keys(libraryLinks).forEach(library => {
        libraryLinks[library].forEach(reference => {
          this.addPositionFromByte(library, sourceFile, reference.start, reference.length)
        })
      })
    })
  }

  private addPositionFromByte(library: string, sourceFile: string, startByte: number, length: number) {
    if (length !== 20) {
      throw new Error(`Unexpected library link length for ${library} at ${startByte}: ${length}`)
    }

    if (!this.links[library]) {
      this.links[library] = {
        positions: [],
        placeholderHash: getPlaceholderHash(`${sourceFile}:${library}`)
      }
    }

    // The `linkReferences` `start` value refers to the byte index in the deployed bytecode.
    // We will be using the position as an index into the hex string representing the bytecode
    // so we need to convert:
    // - Multiply by 2 because every byte takes up two hex characters.
    // - Add 2 to account for the "0x" characters at the start of the bytecode hex string.
    this.links[library].positions.push(startByte * 2 + 2)
  }
}

/*
 * Stores information about linked libraries that is necessary for linking.
 * Specifically, for each library:
 * - `address`: the on-chain address.
 * - `placeholderHash`: the 34-character hexadecimal placeholder hash.
 */
export class LibraryLinkingInfo {
  info: LibraryLinks

  constructor() {
    this.info = {}
  }

  /*
   * Collects and/or checks addresses of linked libraries in a contract, given its deployed bytecode
   * and the expected library linking positions.
   */
  collect = (bytecode: string, artifactLinking: ArtifactLibraryLinking) =>
    Object.keys(artifactLinking.links).forEach((library) => {
      artifactLinking.links[library].positions.forEach((position) => {
        if (!this.addAddress(library, artifactLinking.links[library].placeholderHash, bytecode.slice(position, position + ADDRESS_LENGTH))) {
          throw new Error(`Mismatched addresses for ${library} at ${position}`)
        }
      })
    })

  getAddressMapping = (): { [library: string]: string } => {
    const mapping = {}
    Object.keys(this.info).map(library => {
      mapping[library] = this.info[library].address
    })
    return mapping
  }

  /*
   * Tries to add a library name -> address mapping. If the library has already
   * had an address added, checks that the new address matches the old one.
   */
  private addAddress(library: string, placeholderHash: string, address: string): boolean {
    if (!this.info[library]) {
      this.info[library] = {
        address,
        placeholderHash
      }
    }
    return this.info[library].address === address
  }
}
