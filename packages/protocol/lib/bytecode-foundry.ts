/* eslint-disable max-classes-per-file: 0 */
/*
 * The Solidity compiler appends a Swarm Hash of compilation metadata to the end
 * of bytecode. We find this hash based on the specification here:
 * https://solidity.readthedocs.io/en/develop/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode
 */

import { NULL_ADDRESS, trimLeading0x } from '@celo/base/lib/address'
import { Artifact, LinkReferences } from '@celo/protocol/lib/compatibility/internal'
import { keccak256, toHex } from 'viem'

const CONTRACT_METADATA_REGEXPS = [
  // 0.5.8
  'a165627a7a72305820.{64}0029',
  // 0.5.13
  'a265627a7a72315820.{64}64736f6c6343.{6}0032',
  // 0.8.19
  'a264697066735822.{68}64736f6c6343.{6}0033'
]

const GENERAL_METADATA_REGEXP = new RegExp(
  `^(.*)(${CONTRACT_METADATA_REGEXPS.map((r) => '(' + r + ')').join('|')})$`,
  'i' // Use i flag to make search case insensitive.
)

export const stripMetadata = (bytecode: string): string => {
  if (bytecode === '0x') {
    return '0x'
  }

  const match = bytecode.match(GENERAL_METADATA_REGEXP)
  if (match === null) {
    throw new Error(
      'Only support stripping metadata from bytecodes generated by solc in the versions listed in CONTRACT_METADATA_REGEXPS'
    )
  }
  return match[1]
}

// Maps library fully qualified library names to their onchain addresses (formatted without "0x" prefix).
export interface LibraryLinks {
  [name: string]: {
    address: string,
    placeholder: string
  }
}

/*
 * Unresolved libraries appear as "__$<hash>$__..." in bytecode output by
 * solc. The length of the entire string is 40 characters (accounting for the 20
 * bytes of the address that should be substituted in).
 */
const getPlaceholderHash = (name: string): string => {
  const hash = keccak256(toHex(name))
  return hash.slice(2, 2 + 34)
}


export const linkLibraries = (bytecode: string, libraryLinks: LibraryLinks): string => {
  Object.keys(libraryLinks).forEach((libraryName) => {
    const linkString = `__\\$${libraryLinks[libraryName].placeholder}\\$__`
    // Use g flag to iterate through for all occurences.
    bytecode = bytecode.replace(RegExp(linkString, 'g'), libraryLinks[libraryName].address)
  })

  return bytecode
}

const ADDRESS_LENGTH = 40
const PUSH20_OPCODE = '73'
// To check that a library isn't being called directly, the Solidity
// compiler starts a library's bytecode with a comparison of the current
// address with the address the library was deployed to (it has to differ
// to ensure the library is being called with CALLCODE or DELEGATECALL
// instead of a regular CALL).
// The address is only known at contract construction time, so
// the compiler's output contains a placeholder 0-address, while the onchain
// bytecode has the correct address inserted.
// Reference: https://solidity.readthedocs.io/en/v0.5.12/contracts.html#call-protection-for-libraries
export const verifyAndStripLibraryPrefix = (bytecode: string, address = NULL_ADDRESS) => {
  if (bytecode.slice(2, 4) !== PUSH20_OPCODE) {
    throw new Error(`Library bytecode doesn't start with address load`)
  } else if (bytecode.slice(4, 4 + ADDRESS_LENGTH) !== trimLeading0x(address).toLowerCase()) {
    throw new Error(`Library bytecode loads unexpected address at start`)
  }

  return bytecode.slice(4 + ADDRESS_LENGTH, bytecode.length)
}

export class LibraryPositions {
  positions: {
    [library: string]: {
      pos: number[]
      fullQualified: string
    }
  }

  /*
   * Creates a LibraryPositions object, which, for each yet to be linked library,
   * contains the bytecode offsets of where the library address should be
   * inserted.
   */
  constructor(artifact: Artifact) {
    this.positions = {}
    if (typeof artifact.deployedBytecode !== 'string') {
      this.parseLibraryPositions(artifact.deployedBytecode.linkReferences)
    } else {
      throw new Error(`Unexpected artifact type`)
    }
  }

  private parseLibraryPositions(references: LinkReferences) {
    Object.keys(references).forEach(sourceFile => {
      const libraryLinks = references[sourceFile]
      Object.keys(libraryLinks).forEach(library => {
        libraryLinks[library].forEach(reference => {
          this.addPositionFromByte(library, `${sourceFile}:${library}`, reference.start, reference.length)
        })
      })
    })
  }

  private addPositionFromByte(libName: string, library: string, startByte: number, length: number) {
    if (length !== 20) {
      throw new Error(`Unexpected library link length for ${library} at ${startByte}: ${length}`)
    }

    if (!this.positions[libName]) {
      this.positions[libName] = { pos: [], fullQualified: library }
    }

    // The `linkReferences` `start` value refers to the byte index in the deployed bytecode.
    // We will be using the position as an index into the hex string representing the bytecode
    // so we need to convert:
    // - Multiply by 2 because every byte takes up two hex characters.
    // - Add 2 to account for the "0x" characters at the start of the bytecode hex string.
    this.positions[libName].pos.push(startByte * 2 + 2)
  }
}

export class LibraryAddresses {
  addresses: { [library: string]: { address: string, placeholder: string } }

  constructor() {
    this.addresses = {}
  }

  collect = (bytecode: string, libraryPositions: LibraryPositions) =>
    Object.keys(libraryPositions.positions).forEach((library) => {
      libraryPositions.positions[library].pos.forEach((position) => {
        if (!this.addAddress(library, libraryPositions.positions[library].fullQualified, bytecode.slice(position, position + ADDRESS_LENGTH))) {
          throw new Error(`Mismatched addresses for ${library} at ${position}`)
        }
      })
    })

  /*
   * Tries to add a library name -> address mapping. If the library has already
   * had an address added, checks that the new address matches the old one.
   */
  private addAddress(library: string, fullQualified: string, address: string): boolean {
    if (!this.addresses[library]) {
      this.addresses[library] = {
        address,
        placeholder: getPlaceholderHash(fullQualified)
      }
    }
    return this.addresses[library].address === address
  }
}
